# GitLab CI/CD Configuration for E-commerce Platform
# This pipeline provides comprehensive CI/CD for Kubernetes deployment

stages:
  - 🔍 code-analysis
  - 🧪 test
  - 🐳 build
  - 🔒 security
  - 📦 package
  - 🚀 deploy-staging
  - 🎯 deploy-production

variables:
  # Global Configuration
  DOCKER_DRIVER: overlay2
  DOCKER_BUILDKIT: "1"
  
  # AWS Configuration
  AWS_DEFAULT_REGION: us-west-2
  EKS_CLUSTER_NAME: ecommerce-cluster
  
  # ECR Configuration
  ECR_REGISTRY: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com
  BACKEND_REPO: ecommerce/backend
  FRONTEND_REPO: ecommerce/frontend
  
  # Application Configuration
  K8S_NAMESPACE: ecommerce
  APP_NAME: ecommerce-platform
  
  # Image Tags
  IMAGE_TAG: ${CI_COMMIT_SHORT_SHA}-${CI_PIPELINE_ID}

# Include templates for reusable configurations
include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Container-Scanning.gitlab-ci.yml

# ============================================================================
# 🔍 CODE ANALYSIS STAGE
# ============================================================================

lint-backend:
  stage: 🔍 code-analysis
  image: node:18-alpine
  before_script:
    - cd backend
    - npm ci --cache .npm --prefer-offline
  script:
    - npm run lint
    - npm run lint:report || true
  artifacts:
    reports:
      junit: backend/lint-results.xml
    paths:
      - backend/lint-results.xml
    expire_in: 1 week
  cache:
    key:
      files:
        - backend/package-lock.json
    paths:
      - backend/.npm/
  only:
    changes:
      - backend/**/*
      - .gitlab-ci.yml

lint-frontend:
  stage: 🔍 code-analysis
  image: node:18-alpine
  before_script:
    - cd frontend
    - npm ci --cache .npm --prefer-offline
  script:
    - npm run lint
    - npm run lint:report || true
  artifacts:
    reports:
      junit: frontend/lint-results.xml
    paths:
      - frontend/lint-results.xml
    expire_in: 1 week
  cache:
    key:
      files:
        - frontend/package-lock.json
    paths:
      - frontend/.npm/
  only:
    changes:
      - frontend/**/*
      - .gitlab-ci.yml

validate-k8s:
  stage: 🔍 code-analysis
  image: 
    name: bitnami/kubectl:latest
    entrypoint: [""]
  script:
    - echo "🔍 Validating Kubernetes manifests..."
    - cd k8s
    - |
      for file in *.yaml; do
        echo "Validating $file..."
        kubectl --dry-run=client --validate=true apply -f "$file"
      done
    - echo "✅ All Kubernetes manifests are valid"
  only:
    changes:
      - k8s/**/*
      - .gitlab-ci.yml

# ============================================================================
# 🧪 TEST STAGE
# ============================================================================

test-backend:
  stage: 🧪 test
  image: node:18-alpine
  services:
    - mongo:5.0
    - redis:7-alpine
  variables:
    MONGODB_URL: mongodb://mongo:27017/ecommerce_test
    REDIS_URL: redis://redis:6379
    NODE_ENV: test
  before_script:
    - cd backend
    - npm ci --cache .npm --prefer-offline
  script:
    - npm run test:coverage
  after_script:
    - cd backend
    - npx nyc report --reporter=cobertura
  coverage: '/Lines\s*:\s*(\d+\.?\d*)%/'
  artifacts:
    reports:
      junit: backend/test-results.xml
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage/cobertura-coverage.xml
    paths:
      - backend/coverage/
    expire_in: 1 week
  cache:
    key:
      files:
        - backend/package-lock.json
    paths:
      - backend/.npm/
  only:
    changes:
      - backend/**/*
      - .gitlab-ci.yml

test-frontend:
  stage: 🧪 test
  image: node:18-alpine
  before_script:
    - cd frontend
    - npm ci --cache .npm --prefer-offline
  script:
    - npm run test:coverage -- --watchAll=false
  coverage: '/Lines\s*:\s*(\d+\.?\d*)%/'
  artifacts:
    reports:
      junit: frontend/test-results.xml
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/cobertura-coverage.xml
    paths:
      - frontend/coverage/
    expire_in: 1 week
  cache:
    key:
      files:
        - frontend/package-lock.json
    paths:
      - frontend/.npm/
  only:
    changes:
      - frontend/**/*
      - .gitlab-ci.yml

security-audit:
  stage: 🧪 test
  image: node:18-alpine
  script:
    - echo "🔍 Running security audit..."
    - cd backend && npm audit --audit-level=moderate
    - cd ../frontend && npm audit --audit-level=moderate
    - echo "✅ Security audit completed"
  allow_failure: true
  only:
    changes:
      - backend/**/*
      - frontend/**/*
      - .gitlab-ci.yml

# ============================================================================
# 🐳 BUILD STAGE
# ============================================================================

build-backend:
  stage: 🐳 build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo "🐳 Building backend Docker image..."
    - docker info
  script:
    - cd backend
    - |
      docker build \
        --build-arg NODE_ENV=production \
        --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
        --build-arg VCS_REF=$CI_COMMIT_SHA \
        --build-arg VERSION=$IMAGE_TAG \
        -t ${ECR_REGISTRY}/${BACKEND_REPO}:${IMAGE_TAG} \
        -t ${ECR_REGISTRY}/${BACKEND_REPO}:latest \
        .
    - docker save ${ECR_REGISTRY}/${BACKEND_REPO}:${IMAGE_TAG} | gzip > backend-image.tar.gz
  artifacts:
    paths:
      - backend-image.tar.gz
    expire_in: 1 hour
  only:
    changes:
      - backend/**/*
      - .gitlab-ci.yml

build-frontend:
  stage: 🐳 build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo "🐳 Building frontend Docker image..."
    - docker info
  script:
    - cd frontend
    - |
      docker build \
        --build-arg NODE_ENV=production \
        --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
        --build-arg VCS_REF=$CI_COMMIT_SHA \
        --build-arg VERSION=$IMAGE_TAG \
        -t ${ECR_REGISTRY}/${FRONTEND_REPO}:${IMAGE_TAG} \
        -t ${ECR_REGISTRY}/${FRONTEND_REPO}:latest \
        .
    - docker save ${ECR_REGISTRY}/${FRONTEND_REPO}:${IMAGE_TAG} | gzip > frontend-image.tar.gz
  artifacts:
    paths:
      - frontend-image.tar.gz
    expire_in: 1 hour
  only:
    changes:
      - frontend/**/*
      - .gitlab-ci.yml

# ============================================================================
# 🔒 SECURITY STAGE
# ============================================================================

trivy-backend:
  stage: 🔒 security
  image: aquasec/trivy:latest
  dependencies:
    - build-backend
  before_script:
    - gunzip -c backend-image.tar.gz | docker load
  script:
    - echo "🔒 Scanning backend image for vulnerabilities..."
    - |
      trivy image \
        --exit-code 0 \
        --severity HIGH,CRITICAL \
        --format template \
        --template '@contrib/gitlab.tpl' \
        --output backend-security-report.json \
        ${ECR_REGISTRY}/${BACKEND_REPO}:${IMAGE_TAG}
    - |
      trivy image \
        --exit-code 1 \
        --severity CRITICAL \
        ${ECR_REGISTRY}/${BACKEND_REPO}:${IMAGE_TAG}
  artifacts:
    reports:
      container_scanning: backend-security-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    changes:
      - backend/**/*
      - .gitlab-ci.yml

trivy-frontend:
  stage: 🔒 security
  image: aquasec/trivy:latest
  dependencies:
    - build-frontend
  before_script:
    - gunzip -c frontend-image.tar.gz | docker load
  script:
    - echo "🔒 Scanning frontend image for vulnerabilities..."
    - |
      trivy image \
        --exit-code 0 \
        --severity HIGH,CRITICAL \
        --format template \
        --template '@contrib/gitlab.tpl' \
        --output frontend-security-report.json \
        ${ECR_REGISTRY}/${FRONTEND_REPO}:${IMAGE_TAG}
    - |
      trivy image \
        --exit-code 1 \
        --severity CRITICAL \
        ${ECR_REGISTRY}/${FRONTEND_REPO}:${IMAGE_TAG}
  artifacts:
    reports:
      container_scanning: frontend-security-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    changes:
      - frontend/**/*
      - .gitlab-ci.yml

# ============================================================================
# 📦 PACKAGE STAGE
# ============================================================================

push-to-ecr:
  stage: 📦 package
  image: 
    name: amazon/aws-cli:latest
    entrypoint: [""]
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  dependencies:
    - build-backend
    - build-frontend
  before_script:
    - yum install -y docker
    - docker info
    - aws --version
    - echo "📦 Pushing images to ECR..."
  script:
    # Login to ECR
    - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY
    
    # Load and push backend image
    - gunzip -c backend-image.tar.gz | docker load
    - docker push ${ECR_REGISTRY}/${BACKEND_REPO}:${IMAGE_TAG}
    - docker push ${ECR_REGISTRY}/${BACKEND_REPO}:latest
    
    # Load and push frontend image
    - gunzip -c frontend-image.tar.gz | docker load
    - docker push ${ECR_REGISTRY}/${FRONTEND_REPO}:${IMAGE_TAG}
    - docker push ${ECR_REGISTRY}/${FRONTEND_REPO}:latest
    
    # Output image information
    - echo "✅ Images pushed successfully!"
    - echo "Backend: ${ECR_REGISTRY}/${BACKEND_REPO}:${IMAGE_TAG}"
    - echo "Frontend: ${ECR_REGISTRY}/${FRONTEND_REPO}:${IMAGE_TAG}"
  only:
    refs:
      - main
      - develop
      - /^release\/.*$/

# ============================================================================
# 🚀 STAGING DEPLOYMENT
# ============================================================================

deploy-staging:
  stage: 🚀 deploy-staging
  image: 
    name: bitnami/kubectl:latest
    entrypoint: [""]
  environment:
    name: staging
    url: http://staging.ecommerce.example.com
  before_script:
    - echo "🚀 Deploying to staging environment..."
    - aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name $EKS_CLUSTER_NAME
  script:
    # Create staging namespace
    - kubectl create namespace ${K8S_NAMESPACE}-staging --dry-run=client -o yaml | kubectl apply -f -
    
    # Update image tags in deployments
    - cd k8s
    - sed -i "s|image: .*backend.*|image: ${ECR_REGISTRY}/${BACKEND_REPO}:${IMAGE_TAG}|g" backend-deployment.yaml
    - sed -i "s|image: .*frontend.*|image: ${ECR_REGISTRY}/${FRONTEND_REPO}:${IMAGE_TAG}|g" frontend-deployment.yaml
    
    # Deploy to staging
    - kubectl apply -f . -n ${K8S_NAMESPACE}-staging
    
    # Wait for rollout
    - kubectl rollout status deployment/backend -n ${K8S_NAMESPACE}-staging --timeout=300s
    - kubectl rollout status deployment/frontend -n ${K8S_NAMESPACE}-staging --timeout=300s
    
    # Run smoke tests
    - echo "🧪 Running smoke tests..."
    - kubectl wait --for=condition=ready pod -l app=backend -n ${K8S_NAMESPACE}-staging --timeout=300s
    - BACKEND_IP=$(kubectl get service backend -n ${K8S_NAMESPACE}-staging -o jsonpath='{.spec.clusterIP}')
    - kubectl run curl-test --image=curlimages/curl --rm -i --restart=Never -n ${K8S_NAMESPACE}-staging -- curl -f http://$BACKEND_IP:5000/api/health
  after_script:
    - echo "📊 Deployment summary:"
    - kubectl get pods -n ${K8S_NAMESPACE}-staging
    - kubectl get services -n ${K8S_NAMESPACE}-staging
  only:
    refs:
      - develop
      - /^release\/.*$/

# ============================================================================
# 🎯 PRODUCTION DEPLOYMENT
# ============================================================================

deploy-production:
  stage: 🎯 deploy-production
  image: 
    name: bitnami/kubectl:latest
    entrypoint: [""]
  environment:
    name: production
    url: http://ecommerce.example.com
  when: manual
  before_script:
    - echo "🎯 Deploying to production environment..."
    - aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name $EKS_CLUSTER_NAME
  script:
    # Backup current deployment
    - echo "💾 Creating backup of current deployment..."
    - kubectl get deployment backend -n $K8S_NAMESPACE -o yaml > backup-backend-$(date +%Y%m%d-%H%M%S).yaml
    - kubectl get deployment frontend -n $K8S_NAMESPACE -o yaml > backup-frontend-$(date +%Y%m%d-%H%M%S).yaml
    
    # Update image tags in deployments
    - cd k8s
    - sed -i "s|image: .*backend.*|image: ${ECR_REGISTRY}/${BACKEND_REPO}:${IMAGE_TAG}|g" backend-deployment.yaml
    - sed -i "s|image: .*frontend.*|image: ${ECR_REGISTRY}/${FRONTEND_REPO}:${IMAGE_TAG}|g" frontend-deployment.yaml
    
    # Deploy to production
    - kubectl apply -f . -n $K8S_NAMESPACE
    
    # Wait for rollout with longer timeout for production
    - kubectl rollout status deployment/backend -n $K8S_NAMESPACE --timeout=600s
    - kubectl rollout status deployment/frontend -n $K8S_NAMESPACE --timeout=600s
    
    # Production health checks
    - echo "🔍 Running production health checks..."
    - kubectl wait --for=condition=ready pod -l app=backend -n $K8S_NAMESPACE --timeout=600s
    - kubectl wait --for=condition=ready pod -l app=frontend -n $K8S_NAMESPACE --timeout=600s
    
    # Test ingress endpoint
    - INGRESS_URL=$(kubectl get ingress ecommerce-ingress -n $K8S_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
    - sleep 30  # Allow ingress to propagate
    - curl -f http://$INGRESS_URL/api/health
    - curl -f http://$INGRESS_URL/
  after_script:
    - echo "🎉 Production deployment completed!"
    - echo "📊 Deployment summary:"
    - kubectl get pods -n $K8S_NAMESPACE
    - kubectl get services -n $K8S_NAMESPACE
    - kubectl get ingress -n $K8S_NAMESPACE
  artifacts:
    paths:
      - backup-*.yaml
    expire_in: 30 days
  only:
    refs:
      - main

# ============================================================================
# 📊 NOTIFICATION JOBS
# ============================================================================

notify-success:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\":\"🎉 Production deployment successful!\n\n• Build: $CI_PIPELINE_ID\n• Commit: $CI_COMMIT_SHORT_SHA\n• Images:\n  - Backend: ${ECR_REGISTRY}/${BACKEND_REPO}:${IMAGE_TAG}\n  - Frontend: ${ECR_REGISTRY}/${FRONTEND_REPO}:${IMAGE_TAG}\n\n🔗 Application: http://your-load-balancer-url\"}" \
          $SLACK_WEBHOOK_URL || true
      fi
  when: on_success
  only:
    variables:
      - $SLACK_WEBHOOK_URL

notify-failure:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"💥 Pipeline failed!\n\n• Build: $CI_PIPELINE_ID\n• Branch: $CI_COMMIT_REF_NAME\n• Commit: $CI_COMMIT_SHORT_SHA\n• Stage: $CI_JOB_STAGE\n\n🔗 Pipeline: $CI_PIPELINE_URL\"}" \
        $SLACK_WEBHOOK_URL || true
  when: on_failure
  only:
    variables:
      - $SLACK_WEBHOOK_URL
