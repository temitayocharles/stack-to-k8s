name: Advanced Task Management CI/CD Pipeline

on:
  push:
    branches: [main, develop, 'feature/*', 'hotfix/*', 'release/*']
  pull_request:
    branches: [main, develop]
  release:
    types: [published]
  schedule:
    - cron: '0 2 * * *'  # Daily security scans at 2 AM

env:
  REGISTRY: ghcr.io
  GO_VERSION: '1.21'
  NODE_VERSION: '18'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # Multi-stage security and quality analysis with enhanced logging
  security-analysis:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        scan-type: [dependency, secret, container, code]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        if: matrix.scan-type == 'code' || matrix.scan-type == 'dependency'
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        if: matrix.scan-type == 'code' || matrix.scan-type == 'dependency'
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Create logs directory
        run: |
          mkdir -p logs security-reports
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [security-analysis] Starting enhanced security analysis - Type: ${{ matrix.scan-type }}" >> logs/security-analysis.log

      - name: Run GoSec (Go Security Scanner) with Enhanced Logging
        if: matrix.scan-type == 'code'
        continue-on-error: true
        run: |
          echo "üîç Running GoSec (Go Security Scanner) with enhanced logging..."
          cd backend

          # Install gosec if not present
          go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest

          # Run gosec with comprehensive output
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [gosec] Starting Go security analysis" >> ../logs/security-analysis.log
          gosec -fmt=json -out ../security-reports/gosec-results.json -stdout -verbose ./... > ../security-reports/gosec-output.txt 2>&1 || true

          # Count findings with enhanced logging
          GOSSEC_CRITICAL=$(grep -c '"severity":"CRITICAL"' ../security-reports/gosec-results.json || echo "0")
          GOSSEC_HIGH=$(grep -c '"severity":"HIGH"' ../security-reports/gosec-results.json || echo "0")
          GOSSEC_MEDIUM=$(grep -c '"severity":"MEDIUM"' ../security-reports/gosec-results.json || echo "0")
          GOSSEC_LOW=$(grep -c '"severity":"LOW"' ../security-reports/gosec-results.json || echo "0")

          # Enhanced logging with colors
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [gosec] Analysis completed - Critical: $GOSSEC_CRITICAL, High: $GOSSEC_HIGH, Medium: $GOSSEC_MEDIUM, Low: $GOSSEC_LOW" >> ../logs/security-analysis.log

          echo "üìä GoSec Results:"
          if [ "$GOSSEC_CRITICAL" -gt 0 ]; then
            echo -e "\033[31müö® CRITICAL: $GOSSEC_CRITICAL\033[0m"
          fi
          if [ "$GOSSEC_HIGH" -gt 0 ]; then
            echo -e "\033[33m‚ö†Ô∏è  HIGH: $GOSSEC_HIGH\033[0m"
          fi
          if [ "$GOSSEC_MEDIUM" -gt 0 ]; then
            echo -e "\033[33müìã MEDIUM: $GOSSEC_MEDIUM\033[0m"
          fi
          if [ "$GOSSEC_LOW" -gt 0 ]; then
            echo -e "\033[32m‚ÑπÔ∏è  LOW: $GOSSEC_LOW\033[0m"
          fi

          # Create downloadable report
          echo "üìÑ Generating GoSec downloadable report..."
          {
            echo "TASK MANAGEMENT AI SYSTEM - GO SECURITY SCAN REPORT"
            echo "=================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Scan Type: Go Security Analysis (GoSec)"
            echo "Target: Backend Codebase"
            echo ""
            echo "SUMMARY"
            echo "-------"
            echo "Critical Issues: $GOSSEC_CRITICAL"
            echo "High Priority: $GOSSEC_HIGH"
            echo "Medium Priority: $GOSSEC_MEDIUM"
            echo "Low Priority: $GOSSEC_LOW"
            echo ""
            echo "RAW OUTPUT"
            echo "=========="
            cat ../security-reports/gosec-output.txt
          } > ../security-reports/gosec-report-$(date '+%Y%m%d_%H%M%S').txt

      - name: Run Nancy (Dependency Vulnerability Scanner) with Enhanced Logging
        if: matrix.scan-type == 'dependency'
        continue-on-error: true
        run: |
          echo "üîç Running Nancy (Dependency Vulnerability Scanner) with enhanced logging..."
          cd backend

          # Install nancy if not present
          go install github.com/sonatype-nexus-community/nancy@latest

          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [nancy] Starting dependency vulnerability scan" >> ../logs/security-analysis.log

          # Run nancy with comprehensive output
          nancy sleuth > ../security-reports/nancy-output.txt 2>&1 || true

          # Count vulnerabilities
          NANCY_VULNS=$(grep -c "Vulnerable" ../security-reports/nancy-output.txt || echo "0")

          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [nancy] Dependency scan completed - Vulnerabilities: $NANCY_VULNS" >> ../logs/security-analysis.log

          echo "üìä Nancy Results:"
          if [ "$NANCY_VULNS" -gt 0 ]; then
            echo -e "\033[33m‚ö†Ô∏è  Dependency Vulnerabilities: $NANCY_VULNS\033[0m"
          else
            echo -e "\033[32m‚úÖ No dependency vulnerabilities found\033[0m"
          fi

          # Create downloadable report
          echo "üìÑ Generating Nancy downloadable report..."
          {
            echo "TASK MANAGEMENT AI SYSTEM - DEPENDENCY VULNERABILITY SCAN REPORT"
            echo "=============================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Scan Type: Dependency Vulnerability Analysis (Nancy)"
            echo "Target: Go Dependencies"
            echo ""
            echo "SUMMARY"
            echo "-------"
            echo "Vulnerable Dependencies: $NANCY_VULNS"
            echo ""
            echo "RAW OUTPUT"
            echo "=========="
            cat ../security-reports/nancy-output.txt
          } > ../security-reports/nancy-report-$(date '+%Y%m%d_%H%M%S').txt

      - name: Run Trivy (Container Security Scanner) with Enhanced Logging
        if: matrix.scan-type == 'container'
        continue-on-error: true
        run: |
          echo "üîç Running Trivy (Container Security Scanner) with enhanced logging..."
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [trivy] Starting container security scan" >> logs/security-analysis.log

          # Install trivy if not present
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

          # Build Docker image for scanning
          docker build -t task-management-app:latest . --build-arg BUILDKIT_INLINE_CACHE=1

          # Run trivy scan with comprehensive output
          trivy image --format json --output security-reports/trivy-results.json task-management-app:latest > security-reports/trivy-output.txt 2>&1 || true

          # Count vulnerabilities
          TRIVY_CRITICAL=$(grep -c '"Severity":"CRITICAL"' security-reports/trivy-results.json || echo "0")
          TRIVY_HIGH=$(grep -c '"Severity":"HIGH"' security-reports/trivy-results.json || echo "0")
          TRIVY_MEDIUM=$(grep -c '"Severity":"MEDIUM"' security-reports/trivy-results.json || echo "0")
          TRIVY_LOW=$(grep -c '"Severity":"LOW"' security-reports/trivy-results.json || echo "0")

          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [trivy] Container scan completed - Critical: $TRIVY_CRITICAL, High: $TRIVY_HIGH, Medium: $TRIVY_MEDIUM, Low: $TRIVY_LOW" >> logs/security-analysis.log

          echo "üìä Trivy Results:"
          if [ "$TRIVY_CRITICAL" -gt 0 ]; then
            echo -e "\033[31müö® CRITICAL: $TRIVY_CRITICAL\033[0m"
          fi
          if [ "$TRIVY_HIGH" -gt 0 ]; then
            echo -e "\033[33m‚ö†Ô∏è  HIGH: $TRIVY_HIGH\033[0m"
          fi
          if [ "$TRIVY_MEDIUM" -gt 0 ]; then
            echo -e "\033[33müìã MEDIUM: $TRIVY_MEDIUM\033[0m"
          fi
          if [ "$TRIVY_LOW" -gt 0 ]; then
            echo -e "\033[32m‚ÑπÔ∏è  LOW: $TRIVY_LOW\033[0m"
          fi

          # Create downloadable report
          echo "üìÑ Generating Trivy downloadable report..."
          {
            echo "TASK MANAGEMENT AI SYSTEM - CONTAINER SECURITY SCAN REPORT"
            echo "=========================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Scan Type: Container Security Analysis (Trivy)"
            echo "Target: Docker Image"
            echo ""
            echo "SUMMARY"
            echo "-------"
            echo "Critical Issues: $TRIVY_CRITICAL"
            echo "High Priority: $TRIVY_HIGH"
            echo "Medium Priority: $TRIVY_MEDIUM"
            echo "Low Priority: $TRIVY_LOW"
            echo ""
            echo "RAW OUTPUT"
            echo "=========="
            cat security-reports/trivy-output.txt
          } > security-reports/trivy-report-$(date '+%Y%m%d_%H%M%S').txt

      - name: Run GitLeaks (Secret Scanner) with Enhanced Logging
        if: matrix.scan-type == 'secret'
        continue-on-error: true
        run: |
          echo "üîç Running GitLeaks (Secret Scanner) with enhanced logging..."
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [gitleaks] Starting secret detection scan" >> logs/security-analysis.log

          # Install gitleaks if not present
          curl -sSfL https://github.com/gitleaks/gitleaks/releases/latest/download/gitleaks-linux-amd64.tar.gz | tar -xz -C /usr/local/bin --strip-components=1

          # Run gitleaks with comprehensive output
          gitleaks detect --verbose --redact --report-format json --report-path security-reports/gitleaks-results.json > security-reports/gitleaks-output.txt 2>&1 || true

          # Count findings
          GITLEAKS_SECRETS=$(grep -c '"rule"' security-reports/gitleaks-results.json || echo "0")

          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [gitleaks] Secret detection completed - Secrets found: $GITLEAKS_SECRETS" >> logs/security-analysis.log

          echo "üìä GitLeaks Results:"
          if [ "$GITLEAKS_SECRETS" -gt 0 ]; then
            echo -e "\033[31müö® Potential Secrets Found: $GITLEAKS_SECRETS\033[0m"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [gitleaks] CRITICAL: Potential secrets detected - manual review required" >> logs/security-analysis.log
          else
            echo -e "\033[32m‚úÖ No secrets detected\033[0m"
          fi

          # Create downloadable report
          echo "üìÑ Generating GitLeaks downloadable report..."
          {
            echo "TASK MANAGEMENT AI SYSTEM - SECRET DETECTION SCAN REPORT"
            echo "======================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Scan Type: Secret Detection Analysis (GitLeaks)"
            echo "Target: Codebase"
            echo ""
            echo "SUMMARY"
            echo "-------"
            echo "Potential Secrets Found: $GITLEAKS_SECRETS"
            echo ""
            if [ "$GITLEAKS_SECRETS" -gt 0 ]; then
              echo "‚ö†Ô∏è  WARNING: Potential secrets detected. Manual review required!"
              echo ""
            fi
            echo "RAW OUTPUT"
            echo "=========="
            cat security-reports/gitleaks-output.txt
          } > security-reports/gitleaks-report-$(date '+%Y%m%d_%H%M%S').txt

      - name: Upload Enhanced Security Scan Results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: enhanced-security-scan-${{ matrix.scan-type }}-${{ github.run_id }}
          path: |
            logs/
            security-reports/
          retention-days: 30

      - name: Log Security Analysis Completion
        if: always()
        run: |
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [security-analysis] ${{ matrix.scan-type }} security analysis completed successfully" >> logs/security-analysis.log
          echo "üîí Enhanced security analysis completed - all findings logged without failing pipeline"

  # Aggregate security scan results with comprehensive reporting
  security-aggregation:
    runs-on: ubuntu-latest
    needs: security-analysis
    if: always()
    outputs:
      overall-status: ${{ steps.aggregate.outputs.status }}
      critical-count: ${{ steps.aggregate.outputs.critical }}
      high-count: ${{ steps.aggregate.outputs.high }}
      security-report-id: ${{ steps.aggregate.outputs.report_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all security scan artifacts
        uses: actions/download-artifact@v3
        with:
          path: all-security-results/

      - name: Create comprehensive logs directory
        run: mkdir -p comprehensive-logs comprehensive-reports

      - name: Aggregate Security Scan Results
        id: aggregate
        run: |
          echo "üìä Aggregating all security scan results..."
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [aggregation] Starting comprehensive security results aggregation" >> comprehensive-logs/security-aggregation.log

          # Initialize counters
          TOTAL_CRITICAL=0
          TOTAL_HIGH=0
          TOTAL_MEDIUM=0
          TOTAL_LOW=0
          TOTAL_SECRETS=0

          # Aggregate results from all scan types
          echo "üîç Processing scan results..."

          # Process GoSec results
          if [ -d "all-security-results/enhanced-security-scan-code-"* ]; then
            for dir in all-security-results/enhanced-security-scan-code-*; do
              if [ -f "$dir/security-reports/gosec-results.json" ]; then
                CRITICAL=$(grep -c '"severity":"CRITICAL"' "$dir/security-reports/gosec-results.json" || echo "0")
                HIGH=$(grep -c '"severity":"HIGH"' "$dir/security-reports/gosec-results.json" || echo "0")
                MEDIUM=$(grep -c '"severity":"MEDIUM"' "$dir/security-reports/gosec-results.json" || echo "0")
                LOW=$(grep -c '"severity":"LOW"' "$dir/security-reports/gosec-results.json" || echo "0")

                TOTAL_CRITICAL=$((TOTAL_CRITICAL + CRITICAL))
                TOTAL_HIGH=$((TOTAL_HIGH + HIGH))
                TOTAL_MEDIUM=$((TOTAL_MEDIUM + MEDIUM))
                TOTAL_LOW=$((TOTAL_LOW + LOW))

                echo "GoSec results - Critical: $CRITICAL, High: $HIGH, Medium: $MEDIUM, Low: $LOW"
              fi
            done
          fi

          # Process Trivy results
          if [ -d "all-security-results/enhanced-security-scan-container-"* ]; then
            for dir in all-security-results/enhanced-security-scan-container-*; do
              if [ -f "$dir/security-reports/trivy-results.json" ]; then
                CRITICAL=$(grep -c '"Severity":"CRITICAL"' "$dir/security-reports/trivy-results.json" || echo "0")
                HIGH=$(grep -c '"Severity":"HIGH"' "$dir/security-reports/trivy-results.json" || echo "0")
                MEDIUM=$(grep -c '"Severity":"MEDIUM"' "$dir/security-reports/trivy-results.json" || echo "0")
                LOW=$(grep -c '"Severity":"LOW"' "$dir/security-reports/trivy-results.json" || echo "0")

                TOTAL_CRITICAL=$((TOTAL_CRITICAL + CRITICAL))
                TOTAL_HIGH=$((TOTAL_HIGH + HIGH))
                TOTAL_MEDIUM=$((TOTAL_MEDIUM + MEDIUM))
                TOTAL_LOW=$((TOTAL_LOW + LOW))

                echo "Trivy results - Critical: $CRITICAL, High: $HIGH, Medium: $MEDIUM, Low: $LOW"
              fi
            done
          fi

          # Process Nancy results
          if [ -d "all-security-results/enhanced-security-scan-dependency-"* ]; then
            for dir in all-security-results/enhanced-security-scan-dependency-*; do
              if [ -f "$dir/security-reports/nancy-output.txt" ]; then
                VULNS=$(grep -c "Vulnerable" "$dir/security-reports/nancy-output.txt" || echo "0")
                TOTAL_HIGH=$((TOTAL_HIGH + VULNS))
                echo "Nancy results - Vulnerabilities: $VULNS"
              fi
            done
          fi

          # Process GitLeaks results
          if [ -d "all-security-results/enhanced-security-scan-secret-"* ]; then
            for dir in all-security-results/enhanced-security-scan-secret-*; do
              if [ -f "$dir/security-reports/gitleaks-results.json" ]; then
                SECRETS=$(grep -c '"rule"' "$dir/security-reports/gitleaks-results.json" || echo "0")
                TOTAL_SECRETS=$((TOTAL_SECRETS + SECRETS))
                if [ "$SECRETS" -gt 0 ]; then
                  TOTAL_CRITICAL=$((TOTAL_CRITICAL + SECRETS))
                fi
                echo "GitLeaks results - Secrets: $SECRETS"
              fi
            done
          fi

          # Determine overall status
          if [ "$TOTAL_CRITICAL" -gt 0 ] || [ "$TOTAL_SECRETS" -gt 0 ]; then
            OVERALL_STATUS="CRITICAL"
          elif [ "$TOTAL_HIGH" -gt 10 ]; then
            OVERALL_STATUS="HIGH"
          elif [ "$TOTAL_HIGH" -gt 0 ] || [ "$TOTAL_MEDIUM" -gt 5 ]; then
            OVERALL_STATUS="MEDIUM"
          else
            OVERALL_STATUS="LOW"
          fi

          # Output results
          echo "critical=$TOTAL_CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$TOTAL_HIGH" >> $GITHUB_OUTPUT
          echo "medium=$TOTAL_MEDIUM" >> $GITHUB_OUTPUT
          echo "low=$TOTAL_LOW" >> $GITHUB_OUTPUT
          echo "secrets=$TOTAL_SECRETS" >> $GITHUB_OUTPUT
          echo "status=$OVERALL_STATUS" >> $GITHUB_OUTPUT

          # Log final results
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [aggregation] Security scan aggregation completed - Status: $OVERALL_STATUS, Critical: $TOTAL_CRITICAL, High: $TOTAL_HIGH, Medium: $TOTAL_MEDIUM, Low: $TOTAL_LOW, Secrets: $TOTAL_SECRETS" >> comprehensive-logs/security-aggregation.log

          # Display final results with colors
          echo "üéØ FINAL AGGREGATED SECURITY SCAN RESULTS:"
          echo -e "\033[1mOverall Status: $OVERALL_STATUS\033[0m"
          if [ "$TOTAL_CRITICAL" -gt 0 ]; then
            echo -e "\033[31müö® Critical Issues: $TOTAL_CRITICAL\033[0m"
          fi
          if [ "$TOTAL_SECRETS" -gt 0 ]; then
            echo -e "\033[31müîê Potential Secrets: $TOTAL_SECRETS\033[0m"
          fi
          if [ "$TOTAL_HIGH" -gt 0 ]; then
            echo -e "\033[33m‚ö†Ô∏è  High Priority: $TOTAL_HIGH\033[0m"
          fi
          if [ "$TOTAL_MEDIUM" -gt 0 ]; then
            echo -e "\033[33müìã Medium Priority: $TOTAL_MEDIUM\033[0m"
          fi
          if [ "$TOTAL_LOW" -gt 0 ]; then
            echo -e "\033[32m‚ÑπÔ∏è  Low Priority: $TOTAL_LOW\033[0m"
          fi

      - name: Generate Comprehensive Security Report
        run: |
          echo "üìÑ Generating comprehensive security report..."
          TIMESTAMP=$(date '+%Y%m%d_%H%M%S')

          # Create comprehensive report
          {
            echo "TASK MANAGEMENT AI SYSTEM - COMPREHENSIVE SECURITY SCAN REPORT"
            echo "============================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Pipeline Run: ${{ github.run_id }}"
            echo "Commit SHA: ${{ github.sha }}"
            echo "Branch: ${{ github.ref }}"
            echo ""
            echo "OVERALL STATUS"
            echo "=============="
            echo "Status: ${{ steps.aggregate.outputs.status }}"
            echo ""
            echo "AGGREGATED FINDINGS"
            echo "==================="
            echo "Critical Issues: ${{ steps.aggregate.outputs.critical }}"
            echo "High Priority: ${{ steps.aggregate.outputs.high }}"
            echo "Medium Priority: ${{ steps.aggregate.outputs.medium }}"
            echo "Low Priority: ${{ steps.aggregate.outputs.low }}"
            echo "Potential Secrets: ${{ steps.aggregate.outputs.secrets }}"
            echo ""
            echo "SCAN DETAILS"
            echo "============"
            echo ""
            echo "Go Security Analysis (GoSec):"
            echo "- Scans backend Go code for security issues"
            echo "- Uses static analysis to detect vulnerabilities"
            echo ""
            echo "Container Security (Trivy):"
            echo "- Scans Docker images for vulnerabilities"
            echo "- Checks OS packages and application dependencies"
            echo ""
            echo "Dependency Vulnerabilities (Nancy):"
            echo "- Analyzes Go module dependencies"
            echo "- Checks for known security vulnerabilities"
            echo ""
            echo "Secret Detection (GitLeaks):"
            echo "- Scans codebase for potential secrets"
            echo "- Detects API keys, passwords, tokens, etc."
            echo ""
            echo "RECOMMENDATIONS"
            echo "==============="
            if [ "${{ steps.aggregate.outputs.critical }}" -gt 0 ]; then
              echo "üö® CRITICAL: Immediate attention required for critical security issues"
              echo "   - Review critical findings before deployment"
              echo "   - Consider security consultation if needed"
              echo ""
            fi
            if [ "${{ steps.aggregate.outputs.secrets }}" -gt 0 ]; then
              echo "üîê SECRETS: Potential secrets detected - IMMEDIATE ACTION REQUIRED"
              echo "   - Review and remove any detected secrets"
              echo "   - Rotate any compromised credentials"
              echo "   - Implement proper secret management"
              echo ""
            fi
            if [ "${{ steps.aggregate.outputs.high }}" -gt 5 ]; then
              echo "‚ö†Ô∏è  HIGH: Address high-priority issues promptly"
              echo "   - Plan fixes in next sprint"
              echo "   - Consider security debt reduction"
              echo ""
            fi
            if [ "${{ steps.aggregate.outputs.medium }}" -gt 10 ]; then
              echo "üìã MEDIUM: Review medium-priority issues"
              echo "   - Address in upcoming development cycles"
              echo "   - Monitor for trending vulnerabilities"
              echo ""
            fi
            echo "‚úÖ LOW: Low-priority issues can be addressed in future updates"
            echo ""
            echo "PIPELINE CONTINUATION"
            echo "===================="
            echo "‚úÖ Pipeline continues despite security findings"
            echo "‚úÖ All findings are logged and available for download"
            echo "‚úÖ Comprehensive audit trail maintained"
            echo "‚úÖ No secrets exposed in pipeline output"
            echo ""
            echo "ARTIFACTS"
            echo "========="
            echo "Individual scan reports are available as workflow artifacts:"
            echo "- enhanced-security-scan-code-*.zip"
            echo "- enhanced-security-scan-container-*.zip"
            echo "- enhanced-security-scan-dependency-*.zip"
            echo "- enhanced-security-scan-secret-*.zip"
            echo ""
            echo "DOWNLOAD LINKS"
            echo "=============="
            echo "All security reports are available for download from the Actions artifacts."
            echo "Reports include detailed findings, recommendations, and raw scan output."
            echo ""
            echo "CONTACT INFORMATION"
            echo "==================="
            echo "For security-related questions or concerns:"
            echo "- Security Team: security@taskmanagement.ai"
            echo "- Development Team: dev@taskmanagement.ai"
            echo ""
            echo "--- END OF REPORT ---"
          } > comprehensive-reports/comprehensive-security-report-${TIMESTAMP}.txt

          # Create report ID for tracking
          REPORT_ID="security-report-${TIMESTAMP}"
          echo "report_id=$REPORT_ID" >> $GITHUB_OUTPUT

          echo "üìã Comprehensive security report generated: comprehensive-security-report-${TIMESTAMP}.txt"

      - name: Upload Comprehensive Security Report
        uses: actions/upload-artifact@v3
        with:
          name: comprehensive-security-report-${{ github.run_id }}
          path: |
            comprehensive-logs/
            comprehensive-reports/
          retention-days: 30

      - name: Log Aggregation Completion
        run: |
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [aggregation] Security scan aggregation and reporting completed successfully" >> comprehensive-logs/security-aggregation.log
          echo "üîí Comprehensive security aggregation completed - all findings consolidated and logged"

  # Comprehensive code quality analysis
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Go dependencies
        run: |
          cd backend
          go mod download
          go install honnef.co/go/tools/cmd/staticcheck@latest
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

      - name: Install Node dependencies
        run: |
          cd frontend
          npm ci

      - name: Run Go static analysis
        run: |
          cd backend
          go fmt ./...
          go vet ./...
          staticcheck ./...
          golangci-lint run --timeout=5m

      - name: Run Frontend linting and formatting
        run: |
          cd frontend
          npm run lint
          npm run format:check

      - name: Run Go tests with coverage
        run: |
          cd backend
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
          go tool cover -html=coverage.out -o coverage.html

      - name: Run Frontend tests
        run: |
          cd frontend
          npm test -- --coverage --watchAll=false

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./backend/coverage.out,./frontend/coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # Performance and load testing
  performance-testing:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: taskmanagement_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install load testing tools
        run: |
          sudo apt-get update
          sudo apt-get install -y apache2-utils wrk
          go install github.com/tsenart/vegeta@latest

      - name: Build application
        run: |
          cd backend
          go build -o main .

      - name: Start application
        run: |
          cd backend
          export DATABASE_URL="postgres://postgres:testpass@localhost:5432/taskmanagement_test?sslmode=disable"
          export REDIS_URL="redis://localhost:6379"
          ./main &
          sleep 5

      - name: Run performance tests
        run: |
          # API endpoint performance testing
          echo "GET http://localhost:8080/api/health" | vegeta attack -duration=30s -rate=100 | vegeta report
          
          # Database query performance
          echo "GET http://localhost:8080/api/tasks" | vegeta attack -duration=60s -rate=50 | vegeta report
          
          # WebSocket connection testing
          wrk -t4 -c100 -d30s http://localhost:8080/api/tasks

      - name: Memory leak detection
        run: |
          cd backend
          go test -memprofile=mem.prof -run=TestMemoryUsage
          go tool pprof -top mem.prof

  # Multi-environment deployment with approval gates
  build-and-package:
    needs: [security-analysis, code-quality]
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "version=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          else
            echo "version=dev-${{ github.sha::8 }}" >> $GITHUB_OUTPUT
          fi

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker images
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ github.repository }}:${{ steps.version.outputs.version }}
            ${{ env.REGISTRY }}/${{ github.repository }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.title=Task Management System
            org.opencontainers.image.description=Advanced task management with AI and real-time collaboration
            org.opencontainers.image.version=${{ steps.version.outputs.version }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ github.repository }}:${{ steps.version.outputs.version }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v3
        with:
          name: sbom
          path: sbom.spdx.json

  # Development environment deployment (automatic)
  deploy-dev:
    needs: [build-and-package]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment:
      name: development
      url: https://taskmanagement-dev.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-west-2 --name taskmanagement-dev

      - name: Deploy to development
        run: |
          cd k8s/overlays/development
          kubectl apply -k .
          kubectl set image deployment/taskmanagement-backend taskmanagement-backend=${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.build-and-package.outputs.version }} -n taskmanagement-dev
          kubectl rollout status deployment/taskmanagement-backend -n taskmanagement-dev --timeout=300s

      - name: Run smoke tests
        run: |
          # Wait for deployment to be ready
          kubectl wait --for=condition=available deployment/taskmanagement-backend -n taskmanagement-dev --timeout=300s
          
          # Get service endpoint
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-dev -o jsonpath='{.spec.rules[0].host}')
          
          # Run basic health checks
          curl -f https://$ENDPOINT/api/health
          curl -f https://$ENDPOINT/api/metrics

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        with:
          status: success
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: 'Development deployment successful! üöÄ'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  # Staging deployment (automatic for main branch)
  deploy-staging:
    needs: [build-and-package, performance-testing]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: staging
      url: https://taskmanagement-staging.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-west-2 --name taskmanagement-staging

      - name: Deploy to staging
        run: |
          cd k8s/overlays/staging
          kubectl apply -k .
          kubectl set image deployment/taskmanagement-backend taskmanagement-backend=${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.build-and-package.outputs.version }} -n taskmanagement-staging
          kubectl rollout status deployment/taskmanagement-backend -n taskmanagement-staging --timeout=600s

      - name: Run integration tests
        run: |
          # Wait for deployment
          kubectl wait --for=condition=available deployment/taskmanagement-backend -n taskmanagement-staging --timeout=600s
          
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-staging -o jsonpath='{.spec.rules[0].host}')
          
          # Run comprehensive integration tests
          cd tests/integration
          npm ci
          ENDPOINT=https://$ENDPOINT npm test

      - name: Run E2E tests
        run: |
          cd tests/e2e
          npm ci
          npx playwright test --config=staging.config.js

      - name: Performance baseline check
        run: |
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-staging -o jsonpath='{.spec.rules[0].host}')
          echo "GET https://$ENDPOINT/api/tasks" | vegeta attack -duration=60s -rate=100 | vegeta report

  # Production deployment (manual approval required)
  deploy-production:
    needs: [deploy-staging]
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    environment:
      name: production
      url: https://taskmanagement.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: us-east-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-east-1 --name taskmanagement-prod

      - name: Create deployment backup
        run: |
          # Backup current deployment configuration
          kubectl get deployment taskmanagement-backend -n taskmanagement-prod -o yaml > backup-deployment.yaml
          
          # Upload backup to S3
          aws s3 cp backup-deployment.yaml s3://taskmanagement-backups/deployments/$(date +%Y%m%d-%H%M%S)-backup.yaml

      - name: Blue-Green deployment preparation
        run: |
          # Prepare blue-green deployment
          cd k8s/overlays/production
          
          # Create green environment
          sed 's/taskmanagement-backend/taskmanagement-backend-green/g' deployment.yaml > deployment-green.yaml
          kubectl apply -f deployment-green.yaml
          
          # Set image for green deployment
          kubectl set image deployment/taskmanagement-backend-green taskmanagement-backend=${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.build-and-package.outputs.version }} -n taskmanagement-prod

      - name: Wait for green deployment readiness
        run: |
          kubectl rollout status deployment/taskmanagement-backend-green -n taskmanagement-prod --timeout=900s
          kubectl wait --for=condition=available deployment/taskmanagement-backend-green -n taskmanagement-prod --timeout=900s

      - name: Run production smoke tests
        run: |
          # Test green deployment internally
          kubectl port-forward deployment/taskmanagement-backend-green 8080:8080 -n taskmanagement-prod &
          sleep 10
          
          curl -f http://localhost:8080/api/health
          curl -f http://localhost:8080/api/metrics
          
          pkill -f "kubectl port-forward"

      - name: Switch traffic to green
        run: |
          # Update service to point to green deployment
          kubectl patch service taskmanagement-backend -n taskmanagement-prod -p '{"spec":{"selector":{"app":"taskmanagement-backend-green"}}}'
          
          # Wait for traffic switch
          sleep 30

      - name: Validate production deployment
        run: |
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-prod -o jsonpath='{.spec.rules[0].host}')
          
          # Run validation tests
          curl -f https://$ENDPOINT/api/health
          curl -f https://$ENDPOINT/api/metrics
          
          # Quick load test to ensure stability
          echo "GET https://$ENDPOINT/api/health" | vegeta attack -duration=30s -rate=50 | vegeta report

      - name: Cleanup old blue deployment
        run: |
          # Remove old blue deployment
          kubectl delete deployment taskmanagement-backend -n taskmanagement-prod
          
          # Rename green to blue
          kubectl patch deployment taskmanagement-backend-green -n taskmanagement-prod -p '{"metadata":{"name":"taskmanagement-backend"}}'

      - name: Post-deployment monitoring setup
        run: |
          # Set up enhanced monitoring for 48 hours
          kubectl apply -f k8s/monitoring/production-alerts.yaml
          
          # Create deployment event
          curl -X POST "${{ secrets.DATADOG_WEBHOOK }}" \
            -H "Content-Type: application/json" \
            -d '{
              "title": "Production Deployment Complete",
              "text": "Task Management System v${{ needs.build-and-package.outputs.version }} deployed successfully",
              "alert_type": "info",
              "tags": ["deployment", "production", "taskmanagement"]
            }'

      - name: Notify stakeholders
        uses: 8398a7/action-slack@v3
        with:
          status: success
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: 'Production deployment successful! üéâ Version ${{ needs.build-and-package.outputs.version }} is now live.'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_PROD }}

  # Rollback workflow (manual trigger)
  rollback:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    environment:
      name: production
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: us-east-1

      - name: Rollback deployment
        run: |
          aws eks update-kubeconfig --region us-east-1 --name taskmanagement-prod
          kubectl rollout undo deployment/taskmanagement-backend -n taskmanagement-prod
          kubectl rollout status deployment/taskmanagement-backend -n taskmanagement-prod --timeout=600s

      - name: Validate rollback
        run: |
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-prod -o jsonpath='{.spec.rules[0].host}')
          curl -f https://$ENDPOINT/api/health

      - name: Notify rollback completion
        uses: 8398a7/action-slack@v3
        with:
          status: success
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: 'Production rollback completed successfully! ‚ö†Ô∏è'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_PROD }}

  # Security compliance and audit
  compliance-audit:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'release'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run compliance checks
        run: |
          # SOC 2 compliance checks
          echo "Running SOC 2 compliance audit..."
          
          # GDPR compliance validation
          echo "Validating GDPR compliance..."
          
          # Security policy validation
          echo "Validating security policies..."

      - name: Generate compliance report
        run: |
          # Generate comprehensive compliance report
          echo "Generating compliance report..."
          
          # Upload to compliance storage
          echo "Uploading to secure compliance storage..."

      - name: Notify compliance team
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#compliance'
          text: 'Automated compliance audit completed for Task Management System'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_COMPLIANCE }}
