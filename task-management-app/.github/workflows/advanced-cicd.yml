name: Advanced Task Management CI/CD Pipeline

on:
  push:
    branches: [main, develop, 'feature/*', 'hotfix/*', 'release/*']
  pull_request:
    branches: [main, develop]
  release:
    types: [published]
  schedule:
    - cron: '0 2 * * *'  # Daily security scans at 2 AM

env:
  REGISTRY: ghcr.io
  GO_VERSION: '1.21'
  NODE_VERSION: '18'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # Multi-stage security and quality analysis with enhanced logging
  security-analysis:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        scan-type: [dependency, secret, container, code]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        if: matrix.scan-type == 'code' || matrix.scan-type == 'dependency'
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        if: matrix.scan-type == 'code' || matrix.scan-type == 'dependency'
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Create logs directory
        run: |
          mkdir -p logs security-reports
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [security-analysis] Starting enhanced security analysis - Type: ${{ matrix.scan-type }}" >> logs/security-analysis.log

      - name: Run GoSec (Go Security Scanner) with Enhanced Logging
        if: matrix.scan-type == 'code'
        continue-on-error: true
        run: |
          echo "🔍 Running GoSec (Go Security Scanner) with enhanced logging..."
          cd backend

          # Install gosec if not present
          go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest

          # Run gosec with comprehensive output
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [gosec] Starting Go security analysis" >> ../logs/security-analysis.log
          gosec -fmt=json -out ../security-reports/gosec-results.json -stdout -verbose ./... > ../security-reports/gosec-output.txt 2>&1 || true

          # Count findings with enhanced logging
          GOSSEC_CRITICAL=$(grep -c '"severity":"CRITICAL"' ../security-reports/gosec-results.json || echo "0")
          GOSSEC_HIGH=$(grep -c '"severity":"HIGH"' ../security-reports/gosec-results.json || echo "0")
          GOSSEC_MEDIUM=$(grep -c '"severity":"MEDIUM"' ../security-reports/gosec-results.json || echo "0")
          GOSSEC_LOW=$(grep -c '"severity":"LOW"' ../security-reports/gosec-results.json || echo "0")

          # Enhanced logging with colors
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [gosec] Analysis completed - Critical: $GOSSEC_CRITICAL, High: $GOSSEC_HIGH, Medium: $GOSSEC_MEDIUM, Low: $GOSSEC_LOW" >> ../logs/security-analysis.log

          echo "📊 GoSec Results:"
          if [ "$GOSSEC_CRITICAL" -gt 0 ]; then
            echo -e "\033[31m🚨 CRITICAL: $GOSSEC_CRITICAL\033[0m"
          fi
          if [ "$GOSSEC_HIGH" -gt 0 ]; then
            echo -e "\033[33m⚠️  HIGH: $GOSSEC_HIGH\033[0m"
          fi
          if [ "$GOSSEC_MEDIUM" -gt 0 ]; then
            echo -e "\033[33m📋 MEDIUM: $GOSSEC_MEDIUM\033[0m"
          fi
          if [ "$GOSSEC_LOW" -gt 0 ]; then
            echo -e "\033[32mℹ️  LOW: $GOSSEC_LOW\033[0m"
          fi

          # Create downloadable report
          echo "📄 Generating GoSec downloadable report..."
          {
            echo "TASK MANAGEMENT AI SYSTEM - GO SECURITY SCAN REPORT"
            echo "=================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Scan Type: Go Security Analysis (GoSec)"
            echo "Target: Backend Codebase"
            echo ""
            echo "SUMMARY"
            echo "-------"
            echo "Critical Issues: $GOSSEC_CRITICAL"
            echo "High Priority: $GOSSEC_HIGH"
            echo "Medium Priority: $GOSSEC_MEDIUM"
            echo "Low Priority: $GOSSEC_LOW"
            echo ""
            echo "RAW OUTPUT"
            echo "=========="
            cat ../security-reports/gosec-output.txt
          } > ../security-reports/gosec-report-$(date '+%Y%m%d_%H%M%S').txt

      - name: Run Nancy (Dependency Vulnerability Scanner) with Enhanced Logging
        if: matrix.scan-type == 'dependency'
        continue-on-error: true
        run: |
          echo "🔍 Running Nancy (Dependency Vulnerability Scanner) with enhanced logging..."
          cd backend

          # Install nancy if not present
          go install github.com/sonatype-nexus-community/nancy@latest

          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [nancy] Starting dependency vulnerability scan" >> ../logs/security-analysis.log

          # Run nancy with comprehensive output
          nancy sleuth > ../security-reports/nancy-output.txt 2>&1 || true

          # Count vulnerabilities
          NANCY_VULNS=$(grep -c "Vulnerable" ../security-reports/nancy-output.txt || echo "0")

          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [nancy] Dependency scan completed - Vulnerabilities: $NANCY_VULNS" >> ../logs/security-analysis.log

          echo "📊 Nancy Results:"
          if [ "$NANCY_VULNS" -gt 0 ]; then
            echo -e "\033[33m⚠️  Dependency Vulnerabilities: $NANCY_VULNS\033[0m"
          else
            echo -e "\033[32m✅ No dependency vulnerabilities found\033[0m"
          fi

          # Create downloadable report
          echo "📄 Generating Nancy downloadable report..."
          {
            echo "TASK MANAGEMENT AI SYSTEM - DEPENDENCY VULNERABILITY SCAN REPORT"
            echo "=============================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Scan Type: Dependency Vulnerability Analysis (Nancy)"
            echo "Target: Go Dependencies"
            echo ""
            echo "SUMMARY"
            echo "-------"
            echo "Vulnerable Dependencies: $NANCY_VULNS"
            echo ""
            echo "RAW OUTPUT"
            echo "=========="
            cat ../security-reports/nancy-output.txt
          } > ../security-reports/nancy-report-$(date '+%Y%m%d_%H%M%S').txt

      - name: Run Trivy (Container Security Scanner) with Enhanced Logging
        if: matrix.scan-type == 'container'
        continue-on-error: true
        run: |
          echo "🔍 Running Trivy (Container Security Scanner) with enhanced logging..."
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [trivy] Starting container security scan" >> logs/security-analysis.log

          # Install trivy if not present
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

          # Build Docker image for scanning
          docker build -t task-management-app:latest . --build-arg BUILDKIT_INLINE_CACHE=1

          # Run trivy scan with comprehensive output
          trivy image --format json --output security-reports/trivy-results.json task-management-app:latest > security-reports/trivy-output.txt 2>&1 || true

          # Count vulnerabilities
          TRIVY_CRITICAL=$(grep -c '"Severity":"CRITICAL"' security-reports/trivy-results.json || echo "0")
          TRIVY_HIGH=$(grep -c '"Severity":"HIGH"' security-reports/trivy-results.json || echo "0")
          TRIVY_MEDIUM=$(grep -c '"Severity":"MEDIUM"' security-reports/trivy-results.json || echo "0")
          TRIVY_LOW=$(grep -c '"Severity":"LOW"' security-reports/trivy-results.json || echo "0")

          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [trivy] Container scan completed - Critical: $TRIVY_CRITICAL, High: $TRIVY_HIGH, Medium: $TRIVY_MEDIUM, Low: $TRIVY_LOW" >> logs/security-analysis.log

          echo "📊 Trivy Results:"
          if [ "$TRIVY_CRITICAL" -gt 0 ]; then
            echo -e "\033[31m🚨 CRITICAL: $TRIVY_CRITICAL\033[0m"
          fi
          if [ "$TRIVY_HIGH" -gt 0 ]; then
            echo -e "\033[33m⚠️  HIGH: $TRIVY_HIGH\033[0m"
          fi
          if [ "$TRIVY_MEDIUM" -gt 0 ]; then
            echo -e "\033[33m📋 MEDIUM: $TRIVY_MEDIUM\033[0m"
          fi
          if [ "$TRIVY_LOW" -gt 0 ]; then
            echo -e "\033[32mℹ️  LOW: $TRIVY_LOW\033[0m"
          fi

          # Create downloadable report
          echo "📄 Generating Trivy downloadable report..."
          {
            echo "TASK MANAGEMENT AI SYSTEM - CONTAINER SECURITY SCAN REPORT"
            echo "=========================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Scan Type: Container Security Analysis (Trivy)"
            echo "Target: Docker Image"
            echo ""
            echo "SUMMARY"
            echo "-------"
            echo "Critical Issues: $TRIVY_CRITICAL"
            echo "High Priority: $TRIVY_HIGH"
            echo "Medium Priority: $TRIVY_MEDIUM"
            echo "Low Priority: $TRIVY_LOW"
            echo ""
            echo "RAW OUTPUT"
            echo "=========="
            cat security-reports/trivy-output.txt
          } > security-reports/trivy-report-$(date '+%Y%m%d_%H%M%S').txt

      - name: Run GitLeaks (Secret Scanner) with Enhanced Logging
        if: matrix.scan-type == 'secret'
        continue-on-error: true
        run: |
          echo "🔍 Running GitLeaks (Secret Scanner) with enhanced logging..."
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [gitleaks] Starting secret detection scan" >> logs/security-analysis.log

          # Install gitleaks if not present
          curl -sSfL https://github.com/gitleaks/gitleaks/releases/latest/download/gitleaks-linux-amd64.tar.gz | tar -xz -C /usr/local/bin --strip-components=1

          # Run gitleaks with comprehensive output
          gitleaks detect --verbose --redact --report-format json --report-path security-reports/gitleaks-results.json > security-reports/gitleaks-output.txt 2>&1 || true

          # Count findings
          GITLEAKS_SECRETS=$(grep -c '"rule"' security-reports/gitleaks-results.json || echo "0")

          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [gitleaks] Secret detection completed - Secrets found: $GITLEAKS_SECRETS" >> logs/security-analysis.log

          echo "📊 GitLeaks Results:"
          if [ "$GITLEAKS_SECRETS" -gt 0 ]; then
            echo -e "\033[31m🚨 Potential Secrets Found: $GITLEAKS_SECRETS\033[0m"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [gitleaks] CRITICAL: Potential secrets detected - manual review required" >> logs/security-analysis.log
          else
            echo -e "\033[32m✅ No secrets detected\033[0m"
          fi

          # Create downloadable report
          echo "📄 Generating GitLeaks downloadable report..."
          {
            echo "TASK MANAGEMENT AI SYSTEM - SECRET DETECTION SCAN REPORT"
            echo "======================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Scan Type: Secret Detection Analysis (GitLeaks)"
            echo "Target: Codebase"
            echo ""
            echo "SUMMARY"
            echo "-------"
            echo "Potential Secrets Found: $GITLEAKS_SECRETS"
            echo ""
            if [ "$GITLEAKS_SECRETS" -gt 0 ]; then
              echo "⚠️  WARNING: Potential secrets detected. Manual review required!"
              echo ""
            fi
            echo "RAW OUTPUT"
            echo "=========="
            cat security-reports/gitleaks-output.txt
          } > security-reports/gitleaks-report-$(date '+%Y%m%d_%H%M%S').txt

      - name: Upload Enhanced Security Scan Results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: enhanced-security-scan-${{ matrix.scan-type }}-${{ github.run_id }}
          path: |
            logs/
            security-reports/
          retention-days: 30

      - name: Log Security Analysis Completion
        if: always()
        run: |
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [security-analysis] ${{ matrix.scan-type }} security analysis completed successfully" >> logs/security-analysis.log
          echo "🔒 Enhanced security analysis completed - all findings logged without failing pipeline"

  # Aggregate security scan results with comprehensive reporting
  security-aggregation:
    runs-on: ubuntu-latest
    needs: security-analysis
    if: always()
    outputs:
      overall-status: ${{ steps.aggregate.outputs.status }}
      critical-count: ${{ steps.aggregate.outputs.critical }}
      high-count: ${{ steps.aggregate.outputs.high }}
      security-report-id: ${{ steps.aggregate.outputs.report_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all security scan artifacts
        uses: actions/download-artifact@v3
        with:
          path: all-security-results/

      - name: Create comprehensive logs directory
        run: mkdir -p comprehensive-logs comprehensive-reports

      - name: Aggregate Security Scan Results
        id: aggregate
        run: |
          echo "📊 Aggregating all security scan results..."
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [aggregation] Starting comprehensive security results aggregation" >> comprehensive-logs/security-aggregation.log

          # Initialize counters
          TOTAL_CRITICAL=0
          TOTAL_HIGH=0
          TOTAL_MEDIUM=0
          TOTAL_LOW=0
          TOTAL_SECRETS=0

          # Aggregate results from all scan types
          echo "🔍 Processing scan results..."

          # Process GoSec results
          if [ -d "all-security-results/enhanced-security-scan-code-"* ]; then
            for dir in all-security-results/enhanced-security-scan-code-*; do
              if [ -f "$dir/security-reports/gosec-results.json" ]; then
                CRITICAL=$(grep -c '"severity":"CRITICAL"' "$dir/security-reports/gosec-results.json" || echo "0")
                HIGH=$(grep -c '"severity":"HIGH"' "$dir/security-reports/gosec-results.json" || echo "0")
                MEDIUM=$(grep -c '"severity":"MEDIUM"' "$dir/security-reports/gosec-results.json" || echo "0")
                LOW=$(grep -c '"severity":"LOW"' "$dir/security-reports/gosec-results.json" || echo "0")

                TOTAL_CRITICAL=$((TOTAL_CRITICAL + CRITICAL))
                TOTAL_HIGH=$((TOTAL_HIGH + HIGH))
                TOTAL_MEDIUM=$((TOTAL_MEDIUM + MEDIUM))
                TOTAL_LOW=$((TOTAL_LOW + LOW))

                echo "GoSec results - Critical: $CRITICAL, High: $HIGH, Medium: $MEDIUM, Low: $LOW"
              fi
            done
          fi

          # Process Trivy results
          if [ -d "all-security-results/enhanced-security-scan-container-"* ]; then
            for dir in all-security-results/enhanced-security-scan-container-*; do
              if [ -f "$dir/security-reports/trivy-results.json" ]; then
                CRITICAL=$(grep -c '"Severity":"CRITICAL"' "$dir/security-reports/trivy-results.json" || echo "0")
                HIGH=$(grep -c '"Severity":"HIGH"' "$dir/security-reports/trivy-results.json" || echo "0")
                MEDIUM=$(grep -c '"Severity":"MEDIUM"' "$dir/security-reports/trivy-results.json" || echo "0")
                LOW=$(grep -c '"Severity":"LOW"' "$dir/security-reports/trivy-results.json" || echo "0")

                TOTAL_CRITICAL=$((TOTAL_CRITICAL + CRITICAL))
                TOTAL_HIGH=$((TOTAL_HIGH + HIGH))
                TOTAL_MEDIUM=$((TOTAL_MEDIUM + MEDIUM))
                TOTAL_LOW=$((TOTAL_LOW + LOW))

                echo "Trivy results - Critical: $CRITICAL, High: $HIGH, Medium: $MEDIUM, Low: $LOW"
              fi
            done
          fi

          # Process Nancy results
          if [ -d "all-security-results/enhanced-security-scan-dependency-"* ]; then
            for dir in all-security-results/enhanced-security-scan-dependency-*; do
              if [ -f "$dir/security-reports/nancy-output.txt" ]; then
                VULNS=$(grep -c "Vulnerable" "$dir/security-reports/nancy-output.txt" || echo "0")
                TOTAL_HIGH=$((TOTAL_HIGH + VULNS))
                echo "Nancy results - Vulnerabilities: $VULNS"
              fi
            done
          fi

          # Process GitLeaks results
          if [ -d "all-security-results/enhanced-security-scan-secret-"* ]; then
            for dir in all-security-results/enhanced-security-scan-secret-*; do
              if [ -f "$dir/security-reports/gitleaks-results.json" ]; then
                SECRETS=$(grep -c '"rule"' "$dir/security-reports/gitleaks-results.json" || echo "0")
                TOTAL_SECRETS=$((TOTAL_SECRETS + SECRETS))
                if [ "$SECRETS" -gt 0 ]; then
                  TOTAL_CRITICAL=$((TOTAL_CRITICAL + SECRETS))
                fi
                echo "GitLeaks results - Secrets: $SECRETS"
              fi
            done
          fi

          # Determine overall status
          if [ "$TOTAL_CRITICAL" -gt 0 ] || [ "$TOTAL_SECRETS" -gt 0 ]; then
            OVERALL_STATUS="CRITICAL"
          elif [ "$TOTAL_HIGH" -gt 10 ]; then
            OVERALL_STATUS="HIGH"
          elif [ "$TOTAL_HIGH" -gt 0 ] || [ "$TOTAL_MEDIUM" -gt 5 ]; then
            OVERALL_STATUS="MEDIUM"
          else
            OVERALL_STATUS="LOW"
          fi

          # Output results
          echo "critical=$TOTAL_CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$TOTAL_HIGH" >> $GITHUB_OUTPUT
          echo "medium=$TOTAL_MEDIUM" >> $GITHUB_OUTPUT
          echo "low=$TOTAL_LOW" >> $GITHUB_OUTPUT
          echo "secrets=$TOTAL_SECRETS" >> $GITHUB_OUTPUT
          echo "status=$OVERALL_STATUS" >> $GITHUB_OUTPUT

          # Log final results
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SECURITY] [aggregation] Security scan aggregation completed - Status: $OVERALL_STATUS, Critical: $TOTAL_CRITICAL, High: $TOTAL_HIGH, Medium: $TOTAL_MEDIUM, Low: $TOTAL_LOW, Secrets: $TOTAL_SECRETS" >> comprehensive-logs/security-aggregation.log

          # Display final results with colors
          echo "🎯 FINAL AGGREGATED SECURITY SCAN RESULTS:"
          echo -e "\033[1mOverall Status: $OVERALL_STATUS\033[0m"
          if [ "$TOTAL_CRITICAL" -gt 0 ]; then
            echo -e "\033[31m🚨 Critical Issues: $TOTAL_CRITICAL\033[0m"
          fi
          if [ "$TOTAL_SECRETS" -gt 0 ]; then
            echo -e "\033[31m🔐 Potential Secrets: $TOTAL_SECRETS\033[0m"
          fi
          if [ "$TOTAL_HIGH" -gt 0 ]; then
            echo -e "\033[33m⚠️  High Priority: $TOTAL_HIGH\033[0m"
          fi
          if [ "$TOTAL_MEDIUM" -gt 0 ]; then
            echo -e "\033[33m📋 Medium Priority: $TOTAL_MEDIUM\033[0m"
          fi
          if [ "$TOTAL_LOW" -gt 0 ]; then
            echo -e "\033[32mℹ️  Low Priority: $TOTAL_LOW\033[0m"
          fi

      - name: Generate Comprehensive Security Report
        run: |
          echo "📄 Generating comprehensive security report..."
          TIMESTAMP=$(date '+%Y%m%d_%H%M%S')

          # Create comprehensive report
          {
            echo "TASK MANAGEMENT AI SYSTEM - COMPREHENSIVE SECURITY SCAN REPORT"
            echo "============================================================="
            echo ""
            echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Pipeline Run: ${{ github.run_id }}"
            echo "Commit SHA: ${{ github.sha }}"
            echo "Branch: ${{ github.ref }}"
            echo ""
            echo "OVERALL STATUS"
            echo "=============="
            echo "Status: ${{ steps.aggregate.outputs.status }}"
            echo ""
            echo "AGGREGATED FINDINGS"
            echo "==================="
            echo "Critical Issues: ${{ steps.aggregate.outputs.critical }}"
            echo "High Priority: ${{ steps.aggregate.outputs.high }}"
            echo "Medium Priority: ${{ steps.aggregate.outputs.medium }}"
            echo "Low Priority: ${{ steps.aggregate.outputs.low }}"
            echo "Potential Secrets: ${{ steps.aggregate.outputs.secrets }}"
            echo ""
            echo "SCAN DETAILS"
            echo "============"
            echo ""
            echo "Go Security Analysis (GoSec):"
            echo "- Scans backend Go code for security issues"
            echo "- Uses static analysis to detect vulnerabilities"
            echo ""
            echo "Container Security (Trivy):"
            echo "- Scans Docker images for vulnerabilities"
            echo "- Checks OS packages and application dependencies"
            echo ""
            echo "Dependency Vulnerabilities (Nancy):"
            echo "- Analyzes Go module dependencies"
            echo "- Checks for known security vulnerabilities"
            echo ""
            echo "Secret Detection (GitLeaks):"
            echo "- Scans codebase for potential secrets"
            echo "- Detects API keys, passwords, tokens, etc."
            echo ""
            echo "RECOMMENDATIONS"
            echo "==============="
            if [ "${{ steps.aggregate.outputs.critical }}" -gt 0 ]; then
              echo "🚨 CRITICAL: Immediate attention required for critical security issues"
              echo "   - Review critical findings before deployment"
              echo "   - Consider security consultation if needed"
              echo ""
            fi
            if [ "${{ steps.aggregate.outputs.secrets }}" -gt 0 ]; then
              echo "🔐 SECRETS: Potential secrets detected - IMMEDIATE ACTION REQUIRED"
              echo "   - Review and remove any detected secrets"
              echo "   - Rotate any compromised credentials"
              echo "   - Implement proper secret management"
              echo ""
            fi
            if [ "${{ steps.aggregate.outputs.high }}" -gt 5 ]; then
              echo "⚠️  HIGH: Address high-priority issues promptly"
              echo "   - Plan fixes in next sprint"
              echo "   - Consider security debt reduction"
              echo ""
            fi
            if [ "${{ steps.aggregate.outputs.medium }}" -gt 10 ]; then
              echo "📋 MEDIUM: Review medium-priority issues"
              echo "   - Address in upcoming development cycles"
              echo "   - Monitor for trending vulnerabilities"
              echo ""
            fi
            echo "✅ LOW: Low-priority issues can be addressed in future updates"
            echo ""
            echo "PIPELINE CONTINUATION"
            echo "===================="
            echo "✅ Pipeline continues despite security findings"
            echo "✅ All findings are logged and available for download"
            echo "✅ Comprehensive audit trail maintained"
            echo "✅ No secrets exposed in pipeline output"
            echo ""
            echo "ARTIFACTS"
            echo "========="
            echo "Individual scan reports are available as workflow artifacts:"
            echo "- enhanced-security-scan-code-*.zip"
            echo "- enhanced-security-scan-container-*.zip"
            echo "- enhanced-security-scan-dependency-*.zip"
            echo "- enhanced-security-scan-secret-*.zip"
            echo ""
            echo "DOWNLOAD LINKS"
            echo "=============="
            echo "All security reports are available for download from the Actions artifacts."
            echo "Reports include detailed findings, recommendations, and raw scan output."
            echo ""
            echo "CONTACT INFORMATION"
            echo "==================="
            echo "For security-related questions or concerns:"
            echo "- Security Team: security@taskmanagement.ai"
            echo "- Development Team: dev@taskmanagement.ai"
            echo ""
            echo "--- END OF REPORT ---"
          } > comprehensive-reports/comprehensive-security-report-${TIMESTAMP}.txt

          # Create report ID for tracking
          REPORT_ID="security-report-${TIMESTAMP}"
          echo "report_id=$REPORT_ID" >> $GITHUB_OUTPUT

          echo "📋 Comprehensive security report generated: comprehensive-security-report-${TIMESTAMP}.txt"

      - name: Upload Comprehensive Security Report
        uses: actions/upload-artifact@v3
        with:
          name: comprehensive-security-report-${{ github.run_id }}
          path: |
            comprehensive-logs/
            comprehensive-reports/
          retention-days: 30

      - name: Log Aggregation Completion
        run: |
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] [aggregation] Security scan aggregation and reporting completed successfully" >> comprehensive-logs/security-aggregation.log
          echo "🔒 Comprehensive security aggregation completed - all findings consolidated and logged"

  # Comprehensive code quality analysis
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Go dependencies
        run: |
          cd backend
          go mod download
          go install honnef.co/go/tools/cmd/staticcheck@latest
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

      - name: Install Node dependencies
        run: |
          cd frontend
          npm ci

      - name: Run Go static analysis
        run: |
          cd backend
          go fmt ./...
          go vet ./...
          staticcheck ./...
          golangci-lint run --timeout=5m

      - name: Run Frontend linting and formatting
        run: |
          cd frontend
          npm run lint
          npm run format:check

      - name: Run Go tests with coverage
        run: |
          cd backend
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
          go tool cover -html=coverage.out -o coverage.html

      - name: Run Frontend tests
        run: |
          cd frontend
          npm test -- --coverage --watchAll=false

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./backend/coverage.out,./frontend/coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # Performance and load testing
  performance-testing:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: taskmanagement_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install load testing tools
        run: |
          sudo apt-get update
          sudo apt-get install -y apache2-utils wrk
          go install github.com/tsenart/vegeta@latest

      - name: Build application
        run: |
          cd backend
          go build -o main .

      - name: Start application
        run: |
          cd backend
          export DATABASE_URL="postgres://postgres:testpass@localhost:5432/taskmanagement_test?sslmode=disable"
          export REDIS_URL="redis://localhost:6379"
          ./main &
          sleep 5

      - name: Run performance tests
        run: |
          # API endpoint performance testing
          echo "GET http://localhost:8080/api/health" | vegeta attack -duration=30s -rate=100 | vegeta report
          
          # Database query performance
          echo "GET http://localhost:8080/api/tasks" | vegeta attack -duration=60s -rate=50 | vegeta report
          
          # WebSocket connection testing
          wrk -t4 -c100 -d30s http://localhost:8080/api/tasks

      - name: Memory leak detection
        run: |
          cd backend
          go test -memprofile=mem.prof -run=TestMemoryUsage
          go tool pprof -top mem.prof

  # Multi-environment deployment with approval gates
  build-and-package:
    needs: [security-analysis, code-quality]
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "version=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          else
            echo "version=dev-${{ github.sha::8 }}" >> $GITHUB_OUTPUT
          fi

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker images
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ github.repository }}:${{ steps.version.outputs.version }}
            ${{ env.REGISTRY }}/${{ github.repository }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.title=Task Management System
            org.opencontainers.image.description=Advanced task management with AI and real-time collaboration
            org.opencontainers.image.version=${{ steps.version.outputs.version }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ github.repository }}:${{ steps.version.outputs.version }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v3
        with:
          name: sbom
          path: sbom.spdx.json

  # Development environment deployment (automatic)
  deploy-dev:
    needs: [build-and-package]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment:
      name: development
      url: https://taskmanagement-dev.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-west-2 --name taskmanagement-dev

      - name: Deploy to development
        run: |
          cd k8s/overlays/development
          kubectl apply -k .
          kubectl set image deployment/taskmanagement-backend taskmanagement-backend=${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.build-and-package.outputs.version }} -n taskmanagement-dev
          kubectl rollout status deployment/taskmanagement-backend -n taskmanagement-dev --timeout=300s

      - name: Run smoke tests
        run: |
          # Wait for deployment to be ready
          kubectl wait --for=condition=available deployment/taskmanagement-backend -n taskmanagement-dev --timeout=300s
          
          # Get service endpoint
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-dev -o jsonpath='{.spec.rules[0].host}')
          
          # Run basic health checks
          curl -f https://$ENDPOINT/api/health
          curl -f https://$ENDPOINT/api/metrics

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        with:
          status: success
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: 'Development deployment successful! 🚀'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  # Staging deployment (automatic for main branch)
  deploy-staging:
    needs: [build-and-package, performance-testing]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: staging
      url: https://taskmanagement-staging.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-west-2 --name taskmanagement-staging

      - name: Deploy to staging
        run: |
          cd k8s/overlays/staging
          kubectl apply -k .
          kubectl set image deployment/taskmanagement-backend taskmanagement-backend=${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.build-and-package.outputs.version }} -n taskmanagement-staging
          kubectl rollout status deployment/taskmanagement-backend -n taskmanagement-staging --timeout=600s

      - name: Run integration tests
        run: |
          # Wait for deployment
          kubectl wait --for=condition=available deployment/taskmanagement-backend -n taskmanagement-staging --timeout=600s
          
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-staging -o jsonpath='{.spec.rules[0].host}')
          
          # Run comprehensive integration tests
          cd tests/integration
          npm ci
          ENDPOINT=https://$ENDPOINT npm test

      - name: Run E2E tests
        run: |
          cd tests/e2e
          npm ci
          npx playwright test --config=staging.config.js

      - name: Performance baseline check
        run: |
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-staging -o jsonpath='{.spec.rules[0].host}')
          echo "GET https://$ENDPOINT/api/tasks" | vegeta attack -duration=60s -rate=100 | vegeta report

  # Production deployment (manual approval required)
  deploy-production:
    needs: [deploy-staging]
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    environment:
      name: production
      url: https://taskmanagement.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: us-east-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-east-1 --name taskmanagement-prod

      - name: Create deployment backup
        run: |
          # Backup current deployment configuration
          kubectl get deployment taskmanagement-backend -n taskmanagement-prod -o yaml > backup-deployment.yaml
          
          # Upload backup to S3
          aws s3 cp backup-deployment.yaml s3://taskmanagement-backups/deployments/$(date +%Y%m%d-%H%M%S)-backup.yaml

      - name: Blue-Green deployment preparation
        run: |
          # Prepare blue-green deployment
          cd k8s/overlays/production
          
          # Create green environment
          sed 's/taskmanagement-backend/taskmanagement-backend-green/g' deployment.yaml > deployment-green.yaml
          kubectl apply -f deployment-green.yaml
          
          # Set image for green deployment
          kubectl set image deployment/taskmanagement-backend-green taskmanagement-backend=${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.build-and-package.outputs.version }} -n taskmanagement-prod

      - name: Wait for green deployment readiness
        run: |
          kubectl rollout status deployment/taskmanagement-backend-green -n taskmanagement-prod --timeout=900s
          kubectl wait --for=condition=available deployment/taskmanagement-backend-green -n taskmanagement-prod --timeout=900s

      - name: Run production smoke tests
        run: |
          # Test green deployment internally
          kubectl port-forward deployment/taskmanagement-backend-green 8080:8080 -n taskmanagement-prod &
          sleep 10
          
          curl -f http://localhost:8080/api/health
          curl -f http://localhost:8080/api/metrics
          
          pkill -f "kubectl port-forward"

      - name: Switch traffic to green
        run: |
          # Update service to point to green deployment
          kubectl patch service taskmanagement-backend -n taskmanagement-prod -p '{"spec":{"selector":{"app":"taskmanagement-backend-green"}}}'
          
          # Wait for traffic switch
          sleep 30

      - name: Validate production deployment
        run: |
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-prod -o jsonpath='{.spec.rules[0].host}')
          
          # Run validation tests
          curl -f https://$ENDPOINT/api/health
          curl -f https://$ENDPOINT/api/metrics
          
          # Quick load test to ensure stability
          echo "GET https://$ENDPOINT/api/health" | vegeta attack -duration=30s -rate=50 | vegeta report

      - name: Cleanup old blue deployment
        run: |
          # Remove old blue deployment
          kubectl delete deployment taskmanagement-backend -n taskmanagement-prod
          
          # Rename green to blue
          kubectl patch deployment taskmanagement-backend-green -n taskmanagement-prod -p '{"metadata":{"name":"taskmanagement-backend"}}'

      - name: Post-deployment monitoring setup
        run: |
          # Set up enhanced monitoring for 48 hours
          kubectl apply -f k8s/monitoring/production-alerts.yaml
          
          # Create deployment event
          curl -X POST "${{ secrets.DATADOG_WEBHOOK }}" \
            -H "Content-Type: application/json" \
            -d '{
              "title": "Production Deployment Complete",
              "text": "Task Management System v${{ needs.build-and-package.outputs.version }} deployed successfully",
              "alert_type": "info",
              "tags": ["deployment", "production", "taskmanagement"]
            }'

      - name: Notify stakeholders
        uses: 8398a7/action-slack@v3
        with:
          status: success
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: 'Production deployment successful! 🎉 Version ${{ needs.build-and-package.outputs.version }} is now live.'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_PROD }}

  # Rollback workflow (manual trigger)
  rollback:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    environment:
      name: production
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: us-east-1

      - name: Rollback deployment
        run: |
          aws eks update-kubeconfig --region us-east-1 --name taskmanagement-prod
          kubectl rollout undo deployment/taskmanagement-backend -n taskmanagement-prod
          kubectl rollout status deployment/taskmanagement-backend -n taskmanagement-prod --timeout=600s

      - name: Validate rollback
        run: |
          ENDPOINT=$(kubectl get ingress taskmanagement-ingress -n taskmanagement-prod -o jsonpath='{.spec.rules[0].host}')
          curl -f https://$ENDPOINT/api/health

      - name: Notify rollback completion
        uses: 8398a7/action-slack@v3
        with:
          status: success
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: 'Production rollback completed successfully! ⚠️'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_PROD }}

  # Security compliance and audit
  compliance-audit:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'release'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run compliance checks
        run: |
          # SOC 2 compliance checks
          echo "Running SOC 2 compliance audit..."
          
          # GDPR compliance validation
          echo "Validating GDPR compliance..."
          
          # Security policy validation
          echo "Validating security policies..."

      - name: Generate compliance report
        run: |
          # Generate comprehensive compliance report
          echo "Generating compliance report..."
          
          # Upload to compliance storage
          echo "Uploading to secure compliance storage..."

      - name: Notify compliance team
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#compliance'
          text: 'Automated compliance audit completed for Task Management System'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_COMPLIANCE }}
